{"ast":null,"code":"// import React, { useEffect, useRef } from \"react\";\n\n// const LiquidButton = ({ onClick }) => {\n//   const canvasRef = useRef(null);\n//   let canvas,\n//     context,\n//     pointsA,\n//     pointsB,\n//     mouseX,\n//     mouseY,\n//     relMouseX,\n//     relMouseY,\n//     mouseLastX,\n//     mouseLastY,\n//     mouseDirectionX,\n//     mouseDirectionY,\n//     mouseSpeedX,\n//     mouseSpeedY,\n//     rafID;\n\n//   const points = 8;\n//   const viscosity = 20;\n//   const mouseDist = 70;\n//   const damping = 0.05;\n//   const showIndicators = false;\n//   const buttonWidth = 200;\n//   const buttonHeight = 100;\n\n//   /**\n//    * Get mouse direction\n//    */\n//   function mouseDirection(e) {\n//     if (mouseX < e.pageX) mouseDirectionX = 1;\n//     else if (mouseX > e.pageX) mouseDirectionX = -1;\n//     else mouseDirectionX = 0;\n\n//     if (mouseY < e.pageY) mouseDirectionY = 1;\n//     else if (mouseY > e.pageY) mouseDirectionY = -1;\n//     else mouseDirectionY = 0;\n\n//     mouseX = e.pageX;\n//     mouseY = e.pageY;\n\n//     relMouseX = mouseX - canvas.offsetLeft;\n//     relMouseY = mouseY - canvas.offsetTop;\n//   }\n\n//   /**\n//    * Get mouse speed\n//    */\n//   function mouseSpeed() {\n//     mouseSpeedX = mouseX - mouseLastX;\n//     mouseSpeedY = mouseY - mouseLastY;\n\n//     mouseLastX = mouseX;\n//     mouseLastY = mouseY;\n\n//     setTimeout(mouseSpeed, 50);\n//   }\n\n//   /**\n//    * Init button\n//    */\n//   function initButton() {\n//     // Get button\n//     const button = document.querySelector(\".btn-liquid\");\n\n//     // Create canvas\n//     canvas = canvasRef.current;\n//     context = canvas.getContext(\"2d\");\n\n//     canvas.width = buttonWidth + 100;\n//     canvas.height = buttonHeight + 100;\n\n//     // Initialize variables\n//     pointsA = [];\n//     pointsB = [];\n//     mouseX = 0;\n//     mouseY = 0;\n//     relMouseX = 0;\n//     relMouseY = 0;\n//     mouseLastX = 0;\n//     mouseLastY = 0;\n//     mouseDirectionX = 0;\n//     mouseDirectionY = 0;\n//     mouseSpeedX = 0;\n//     mouseSpeedY = 0;\n\n//     // Add points\n//     let x = buttonHeight / 2;\n//     for (let j = 1; j < points; j++) {\n//       addPoints(x + ((buttonWidth - buttonHeight) / points) * j, 0);\n//     }\n//     addPoints(buttonWidth - buttonHeight / 5, 0);\n//     addPoints(buttonWidth + buttonHeight / 10, buttonHeight / 2);\n//     addPoints(buttonWidth - buttonHeight / 5, buttonHeight);\n//     for (let j = points - 1; j > 0; j--) {\n//       addPoints(x + ((buttonWidth - buttonHeight) / points) * j, buttonHeight);\n//     }\n//     addPoints(buttonHeight / 5, buttonHeight);\n//     addPoints(-buttonHeight / 10, buttonHeight / 2);\n//     addPoints(buttonHeight / 5, 0);\n\n//     button.addEventListener(\"mousemove\", mouseDirection);\n\n//     renderCanvas();\n//   }\n\n//   /**\n//    * Add points\n//    */\n//   function addPoints(x, y) {\n//     pointsA.push(new Point(x, y, 1));\n//     pointsB.push(new Point(x, y, 2));\n//   }\n\n//   /**\n//    * Point\n//    */\n//   class Point {\n//     constructor(x, y, level) {\n//       this.x = this.ix = 50 + x;\n//       this.y = this.iy = 50 + y;\n//       this.vx = 0;\n//       this.vy = 0;\n//       this.cx1 = 0;\n//       this.cy1 = 0;\n//       this.cx2 = 0;\n//       this.cy2 = 0;\n//       this.level = level;\n//     }\n\n//     /**\n//      * Move point by velocity\n//      */\n//     move() {\n//       this.vx += (this.ix - this.x) / viscosity;\n//       this.vy += (this.iy - this.y) / viscosity;\n\n//       let dx = this.ix - relMouseX,\n//         dy = this.iy - relMouseY;\n//       let relDist = 1 - Math.sqrt(dx * dx + dy * dy) / mouseDist;\n\n//       // Move x\n//       if (\n//         (mouseDirectionX > 0 && relMouseX > this.x) ||\n//         (mouseDirectionX < 0 && relMouseX < this.x)\n//       ) {\n//         if (relDist > 0 && relDist < 1) {\n//           this.vx = (mouseSpeedX / 4) * relDist;\n//         }\n//       }\n//       this.vx *= 1 - damping;\n//       this.x += this.vx;\n\n//       // Move y\n//       if (\n//         (mouseDirectionY > 0 && relMouseY > this.y) ||\n//         (mouseDirectionY < 0 && relMouseY < this.y)\n//       ) {\n//         if (relDist > 0 && relDist < 1) {\n//           this.vy = (mouseSpeedY / 4) * relDist;\n//         }\n//       }\n//       this.vy *= 1 - damping;\n//       this.y += this.vy;\n//     }\n//   }\n\n//   /**\n//    * Render canvas\n//    */\n//   function renderCanvas() {\n//     // rAF\n//     rafID = requestAnimationFrame(renderCanvas);\n\n//     // Clear scene\n//     context.clearRect(0, 0, canvas.width, canvas.height);\n\n//     // Move points\n//     for (let i = 0; i <= pointsA.length - 1; i++) {\n//       pointsA[i].move();\n//       pointsB[i].move();\n//     }\n\n//     // Create dynamic gradient\n//     const gradientX = Math.min(\n//       Math.max(mouseX - canvas.offsetLeft - buttonWidth / 2, 0),\n//       buttonWidth\n//     );\n//     const gradientY = Math.min(\n//       Math.max(mouseY - canvas.offsetTop - buttonHeight / 2, 0),\n//       buttonHeight\n//     );\n//     const distance =\n//       Math.sqrt(\n//         Math.pow(gradientX - buttonWidth / 2, 2) +\n//           Math.pow(gradientY - buttonHeight / 2, 2)\n//       ) /\n//       Math.sqrt(Math.pow(buttonWidth / 2, 2) + Math.pow(buttonHeight / 2, 2));\n\n//     const gradient = context.createRadialGradient(\n//       gradientX + canvas.offsetLeft,\n//       gradientY + canvas.offsetTop,\n//       300 + 300 * distance,\n//       gradientX + canvas.offsetLeft,\n//       gradientY + canvas.offsetTop,\n//       0\n//     );\n//     gradient.addColorStop(0, \"#ff1050\");\n//     gradient.addColorStop(1, \"#ffad11\");\n\n//     // Draw shapes\n//     const groups = [pointsA, pointsB];\n\n//     for (let j = 0; j <= 1; j++) {\n//       const points = groups[j];\n\n//       if (j === 0) {\n//         // Background style\n//         context.fillStyle = \"#1c1c1c\";\n//       } else {\n//         // Foreground style\n//         context.fillStyle = gradient;\n//       }\n\n//       context.beginPath();\n//       context.moveTo(points[0].x, points[0].y);\n\n//       for (let i = 0; i < points.length; i++) {\n//         const p = points[i];\n//         const nextP = points[i + 1];\n//         const val = 30 * 0.552284749831;\n\n//         if (nextP !== undefined) {\n//           // if (nextP.ix > p.ix && nextP.iy < p.iy) {\n//           //   p.cx1 = p.x;\n//           //   p.cy1 = p.y - val;\n//           //   p.cx2 = nextP.x - val;\n//           //   p.cy2 = nextP.y;\n//           // } else if (nextP.ix > p.ix && nextP.iy > p.iy) {\n//           //   p.cx1 = p.x + val;\n//           //   p.cy1 = p.y;\n//           //   p.cx2 = nextP.x;\n//           //   p.cy2 = nextP.y - val;\n//           // } else if (nextP.ix < p.ix && nextP.iy > p.iy) {\n//           //   p.cx1 = p.x;\n//           //   p.cy1 = p.y + val;\n//           //   p.cx2 = nextP.x + val;\n//           //   p.cy2 = nextP.y;\n//           // } else if (nextP.ix < p.ix && nextP.iy < p.iy) {\n//           //   p.cx1 = p.x - val;\n//           //   p.cy1 = p.y;\n//           //   p.cx2 = nextP.x;\n//           //   p.cy2 = nextP.y + val;\n//           // } else {\n\n//           p.cx1 = (p.x + nextP.x) / 2;\n//           p.cy1 = (p.y + nextP.y) / 2;\n//           p.cx2 = (p.x + nextP.x) / 2;\n//           p.cy2 = (p.y + nextP.y) / 2;\n\n//           context.bezierCurveTo(p.x, p.y, p.cx1, p.cy1, p.cx1, p.cy1);\n//           // context.lineTo(p.x, p.y);\n//           // context.lineTo(p.cx1, p.cy1);\n//           // context.lineTo(p.cx2, p.cy2);\n//           // context.lineTo(nextP.x, nextP.y);\n//         } else {\n//           nextP = points[0];\n//           p.cx1 = (p.x + nextP.x) / 2;\n//           p.cy1 = (p.y + nextP.y) / 2;\n\n//           context.bezierCurveTo(p.x, p.y, p.cx1, p.cy1, p.cx1, p.cy1);\n//         }\n//       }\n\n//       // context.closePath();\n//       context.fill();\n//     }\n\n//     if (showIndicators) {\n//       // Draw points\n//       context.fillStyle = \"#000\";\n//       context.beginPath();\n//       for (let i = 0; i < pointsA.length; i++) {\n//         const p = pointsA[i];\n\n//         context.rect(p.x - 1, p.y - 1, 2, 2);\n//       }\n//       context.fill();\n\n//       // Draw controls\n//       context.fillStyle = \"#f00\";\n//       context.beginPath();\n//       for (let i = 0; i < pointsA.length; i++) {\n//         const p = pointsA[i];\n\n//         context.rect(p.cx1 - 1, p.cy1 - 1, 2, 2);\n//         context.rect(p.cx2 - 1, p.cy2 - 1, 2, 2);\n//       }\n//       context.fill();\n//     }\n//   }\n\n//   useEffect(() => {\n//     initButton();\n//     mouseSpeed();\n\n//     return () => {\n//       cancelAnimationFrame(rafID);\n//     };\n//   }, []);\n\n//   return <canvas ref={canvasRef} className=\"btn-liquid\" />;\n// };\n\n// export default LiquidButton;","map":{"version":3,"names":[],"sources":["C:/Users/melni/Documents/GitHub/General_Page/my-app/src/components/Auth/LiquidButton.jsx"],"sourcesContent":["// import React, { useEffect, useRef } from \"react\";\r\n\r\n// const LiquidButton = ({ onClick }) => {\r\n//   const canvasRef = useRef(null);\r\n//   let canvas,\r\n//     context,\r\n//     pointsA,\r\n//     pointsB,\r\n//     mouseX,\r\n//     mouseY,\r\n//     relMouseX,\r\n//     relMouseY,\r\n//     mouseLastX,\r\n//     mouseLastY,\r\n//     mouseDirectionX,\r\n//     mouseDirectionY,\r\n//     mouseSpeedX,\r\n//     mouseSpeedY,\r\n//     rafID;\r\n\r\n//   const points = 8;\r\n//   const viscosity = 20;\r\n//   const mouseDist = 70;\r\n//   const damping = 0.05;\r\n//   const showIndicators = false;\r\n//   const buttonWidth = 200;\r\n//   const buttonHeight = 100;\r\n\r\n//   /**\r\n//    * Get mouse direction\r\n//    */\r\n//   function mouseDirection(e) {\r\n//     if (mouseX < e.pageX) mouseDirectionX = 1;\r\n//     else if (mouseX > e.pageX) mouseDirectionX = -1;\r\n//     else mouseDirectionX = 0;\r\n\r\n//     if (mouseY < e.pageY) mouseDirectionY = 1;\r\n//     else if (mouseY > e.pageY) mouseDirectionY = -1;\r\n//     else mouseDirectionY = 0;\r\n\r\n//     mouseX = e.pageX;\r\n//     mouseY = e.pageY;\r\n\r\n//     relMouseX = mouseX - canvas.offsetLeft;\r\n//     relMouseY = mouseY - canvas.offsetTop;\r\n//   }\r\n\r\n//   /**\r\n//    * Get mouse speed\r\n//    */\r\n//   function mouseSpeed() {\r\n//     mouseSpeedX = mouseX - mouseLastX;\r\n//     mouseSpeedY = mouseY - mouseLastY;\r\n\r\n//     mouseLastX = mouseX;\r\n//     mouseLastY = mouseY;\r\n\r\n//     setTimeout(mouseSpeed, 50);\r\n//   }\r\n\r\n//   /**\r\n//    * Init button\r\n//    */\r\n//   function initButton() {\r\n//     // Get button\r\n//     const button = document.querySelector(\".btn-liquid\");\r\n\r\n//     // Create canvas\r\n//     canvas = canvasRef.current;\r\n//     context = canvas.getContext(\"2d\");\r\n\r\n//     canvas.width = buttonWidth + 100;\r\n//     canvas.height = buttonHeight + 100;\r\n\r\n//     // Initialize variables\r\n//     pointsA = [];\r\n//     pointsB = [];\r\n//     mouseX = 0;\r\n//     mouseY = 0;\r\n//     relMouseX = 0;\r\n//     relMouseY = 0;\r\n//     mouseLastX = 0;\r\n//     mouseLastY = 0;\r\n//     mouseDirectionX = 0;\r\n//     mouseDirectionY = 0;\r\n//     mouseSpeedX = 0;\r\n//     mouseSpeedY = 0;\r\n\r\n//     // Add points\r\n//     let x = buttonHeight / 2;\r\n//     for (let j = 1; j < points; j++) {\r\n//       addPoints(x + ((buttonWidth - buttonHeight) / points) * j, 0);\r\n//     }\r\n//     addPoints(buttonWidth - buttonHeight / 5, 0);\r\n//     addPoints(buttonWidth + buttonHeight / 10, buttonHeight / 2);\r\n//     addPoints(buttonWidth - buttonHeight / 5, buttonHeight);\r\n//     for (let j = points - 1; j > 0; j--) {\r\n//       addPoints(x + ((buttonWidth - buttonHeight) / points) * j, buttonHeight);\r\n//     }\r\n//     addPoints(buttonHeight / 5, buttonHeight);\r\n//     addPoints(-buttonHeight / 10, buttonHeight / 2);\r\n//     addPoints(buttonHeight / 5, 0);\r\n\r\n//     button.addEventListener(\"mousemove\", mouseDirection);\r\n\r\n//     renderCanvas();\r\n//   }\r\n\r\n//   /**\r\n//    * Add points\r\n//    */\r\n//   function addPoints(x, y) {\r\n//     pointsA.push(new Point(x, y, 1));\r\n//     pointsB.push(new Point(x, y, 2));\r\n//   }\r\n\r\n//   /**\r\n//    * Point\r\n//    */\r\n//   class Point {\r\n//     constructor(x, y, level) {\r\n//       this.x = this.ix = 50 + x;\r\n//       this.y = this.iy = 50 + y;\r\n//       this.vx = 0;\r\n//       this.vy = 0;\r\n//       this.cx1 = 0;\r\n//       this.cy1 = 0;\r\n//       this.cx2 = 0;\r\n//       this.cy2 = 0;\r\n//       this.level = level;\r\n//     }\r\n\r\n//     /**\r\n//      * Move point by velocity\r\n//      */\r\n//     move() {\r\n//       this.vx += (this.ix - this.x) / viscosity;\r\n//       this.vy += (this.iy - this.y) / viscosity;\r\n\r\n//       let dx = this.ix - relMouseX,\r\n//         dy = this.iy - relMouseY;\r\n//       let relDist = 1 - Math.sqrt(dx * dx + dy * dy) / mouseDist;\r\n\r\n//       // Move x\r\n//       if (\r\n//         (mouseDirectionX > 0 && relMouseX > this.x) ||\r\n//         (mouseDirectionX < 0 && relMouseX < this.x)\r\n//       ) {\r\n//         if (relDist > 0 && relDist < 1) {\r\n//           this.vx = (mouseSpeedX / 4) * relDist;\r\n//         }\r\n//       }\r\n//       this.vx *= 1 - damping;\r\n//       this.x += this.vx;\r\n\r\n//       // Move y\r\n//       if (\r\n//         (mouseDirectionY > 0 && relMouseY > this.y) ||\r\n//         (mouseDirectionY < 0 && relMouseY < this.y)\r\n//       ) {\r\n//         if (relDist > 0 && relDist < 1) {\r\n//           this.vy = (mouseSpeedY / 4) * relDist;\r\n//         }\r\n//       }\r\n//       this.vy *= 1 - damping;\r\n//       this.y += this.vy;\r\n//     }\r\n//   }\r\n\r\n//   /**\r\n//    * Render canvas\r\n//    */\r\n//   function renderCanvas() {\r\n//     // rAF\r\n//     rafID = requestAnimationFrame(renderCanvas);\r\n\r\n//     // Clear scene\r\n//     context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n//     // Move points\r\n//     for (let i = 0; i <= pointsA.length - 1; i++) {\r\n//       pointsA[i].move();\r\n//       pointsB[i].move();\r\n//     }\r\n\r\n//     // Create dynamic gradient\r\n//     const gradientX = Math.min(\r\n//       Math.max(mouseX - canvas.offsetLeft - buttonWidth / 2, 0),\r\n//       buttonWidth\r\n//     );\r\n//     const gradientY = Math.min(\r\n//       Math.max(mouseY - canvas.offsetTop - buttonHeight / 2, 0),\r\n//       buttonHeight\r\n//     );\r\n//     const distance =\r\n//       Math.sqrt(\r\n//         Math.pow(gradientX - buttonWidth / 2, 2) +\r\n//           Math.pow(gradientY - buttonHeight / 2, 2)\r\n//       ) /\r\n//       Math.sqrt(Math.pow(buttonWidth / 2, 2) + Math.pow(buttonHeight / 2, 2));\r\n\r\n//     const gradient = context.createRadialGradient(\r\n//       gradientX + canvas.offsetLeft,\r\n//       gradientY + canvas.offsetTop,\r\n//       300 + 300 * distance,\r\n//       gradientX + canvas.offsetLeft,\r\n//       gradientY + canvas.offsetTop,\r\n//       0\r\n//     );\r\n//     gradient.addColorStop(0, \"#ff1050\");\r\n//     gradient.addColorStop(1, \"#ffad11\");\r\n\r\n//     // Draw shapes\r\n//     const groups = [pointsA, pointsB];\r\n\r\n//     for (let j = 0; j <= 1; j++) {\r\n//       const points = groups[j];\r\n\r\n//       if (j === 0) {\r\n//         // Background style\r\n//         context.fillStyle = \"#1c1c1c\";\r\n//       } else {\r\n//         // Foreground style\r\n//         context.fillStyle = gradient;\r\n//       }\r\n\r\n//       context.beginPath();\r\n//       context.moveTo(points[0].x, points[0].y);\r\n\r\n//       for (let i = 0; i < points.length; i++) {\r\n//         const p = points[i];\r\n//         const nextP = points[i + 1];\r\n//         const val = 30 * 0.552284749831;\r\n\r\n//         if (nextP !== undefined) {\r\n//           // if (nextP.ix > p.ix && nextP.iy < p.iy) {\r\n//           //   p.cx1 = p.x;\r\n//           //   p.cy1 = p.y - val;\r\n//           //   p.cx2 = nextP.x - val;\r\n//           //   p.cy2 = nextP.y;\r\n//           // } else if (nextP.ix > p.ix && nextP.iy > p.iy) {\r\n//           //   p.cx1 = p.x + val;\r\n//           //   p.cy1 = p.y;\r\n//           //   p.cx2 = nextP.x;\r\n//           //   p.cy2 = nextP.y - val;\r\n//           // } else if (nextP.ix < p.ix && nextP.iy > p.iy) {\r\n//           //   p.cx1 = p.x;\r\n//           //   p.cy1 = p.y + val;\r\n//           //   p.cx2 = nextP.x + val;\r\n//           //   p.cy2 = nextP.y;\r\n//           // } else if (nextP.ix < p.ix && nextP.iy < p.iy) {\r\n//           //   p.cx1 = p.x - val;\r\n//           //   p.cy1 = p.y;\r\n//           //   p.cx2 = nextP.x;\r\n//           //   p.cy2 = nextP.y + val;\r\n//           // } else {\r\n\r\n//           p.cx1 = (p.x + nextP.x) / 2;\r\n//           p.cy1 = (p.y + nextP.y) / 2;\r\n//           p.cx2 = (p.x + nextP.x) / 2;\r\n//           p.cy2 = (p.y + nextP.y) / 2;\r\n\r\n//           context.bezierCurveTo(p.x, p.y, p.cx1, p.cy1, p.cx1, p.cy1);\r\n//           // context.lineTo(p.x, p.y);\r\n//           // context.lineTo(p.cx1, p.cy1);\r\n//           // context.lineTo(p.cx2, p.cy2);\r\n//           // context.lineTo(nextP.x, nextP.y);\r\n//         } else {\r\n//           nextP = points[0];\r\n//           p.cx1 = (p.x + nextP.x) / 2;\r\n//           p.cy1 = (p.y + nextP.y) / 2;\r\n\r\n//           context.bezierCurveTo(p.x, p.y, p.cx1, p.cy1, p.cx1, p.cy1);\r\n//         }\r\n//       }\r\n\r\n//       // context.closePath();\r\n//       context.fill();\r\n//     }\r\n\r\n//     if (showIndicators) {\r\n//       // Draw points\r\n//       context.fillStyle = \"#000\";\r\n//       context.beginPath();\r\n//       for (let i = 0; i < pointsA.length; i++) {\r\n//         const p = pointsA[i];\r\n\r\n//         context.rect(p.x - 1, p.y - 1, 2, 2);\r\n//       }\r\n//       context.fill();\r\n\r\n//       // Draw controls\r\n//       context.fillStyle = \"#f00\";\r\n//       context.beginPath();\r\n//       for (let i = 0; i < pointsA.length; i++) {\r\n//         const p = pointsA[i];\r\n\r\n//         context.rect(p.cx1 - 1, p.cy1 - 1, 2, 2);\r\n//         context.rect(p.cx2 - 1, p.cy2 - 1, 2, 2);\r\n//       }\r\n//       context.fill();\r\n//     }\r\n//   }\r\n\r\n//   useEffect(() => {\r\n//     initButton();\r\n//     mouseSpeed();\r\n\r\n//     return () => {\r\n//       cancelAnimationFrame(rafID);\r\n//     };\r\n//   }, []);\r\n\r\n//   return <canvas ref={canvasRef} className=\"btn-liquid\" />;\r\n// };\r\n\r\n// export default LiquidButton;\r\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}